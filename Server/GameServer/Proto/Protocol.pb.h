// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class CS_FIELD_LOADING_COMPLETE;
struct CS_FIELD_LOADING_COMPLETEDefaultTypeInternal;
extern CS_FIELD_LOADING_COMPLETEDefaultTypeInternal _CS_FIELD_LOADING_COMPLETE_default_instance_;
class CS_MOVE;
struct CS_MOVEDefaultTypeInternal;
extern CS_MOVEDefaultTypeInternal _CS_MOVE_default_instance_;
class CS_PING;
struct CS_PINGDefaultTypeInternal;
extern CS_PINGDefaultTypeInternal _CS_PING_default_instance_;
class CS_REQ_ENTER_GAME;
struct CS_REQ_ENTER_GAMEDefaultTypeInternal;
extern CS_REQ_ENTER_GAMEDefaultTypeInternal _CS_REQ_ENTER_GAME_default_instance_;
class CS_REQ_MOVE_FIELD;
struct CS_REQ_MOVE_FIELDDefaultTypeInternal;
extern CS_REQ_MOVE_FIELDDefaultTypeInternal _CS_REQ_MOVE_FIELD_default_instance_;
class SC_DESPAWN_PLAYER;
struct SC_DESPAWN_PLAYERDefaultTypeInternal;
extern SC_DESPAWN_PLAYERDefaultTypeInternal _SC_DESPAWN_PLAYER_default_instance_;
class SC_ENTER_FIELD;
struct SC_ENTER_FIELDDefaultTypeInternal;
extern SC_ENTER_FIELDDefaultTypeInternal _SC_ENTER_FIELD_default_instance_;
class SC_ENTER_GAME_RESULT;
struct SC_ENTER_GAME_RESULTDefaultTypeInternal;
extern SC_ENTER_GAME_RESULTDefaultTypeInternal _SC_ENTER_GAME_RESULT_default_instance_;
class SC_MOVE_FIELD_FAIL;
struct SC_MOVE_FIELD_FAILDefaultTypeInternal;
extern SC_MOVE_FIELD_FAILDefaultTypeInternal _SC_MOVE_FIELD_FAIL_default_instance_;
class SC_PONG;
struct SC_PONGDefaultTypeInternal;
extern SC_PONGDefaultTypeInternal _SC_PONG_default_instance_;
class SC_SPAWN_PLAYER;
struct SC_SPAWN_PLAYERDefaultTypeInternal;
extern SC_SPAWN_PLAYERDefaultTypeInternal _SC_SPAWN_PLAYER_default_instance_;
class SC_START_FIELD_LOADING;
struct SC_START_FIELD_LOADINGDefaultTypeInternal;
extern SC_START_FIELD_LOADINGDefaultTypeInternal _SC_START_FIELD_LOADING_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::CS_FIELD_LOADING_COMPLETE* Arena::CreateMaybeMessage<::Protocol::CS_FIELD_LOADING_COMPLETE>(Arena*);
template<> ::Protocol::CS_MOVE* Arena::CreateMaybeMessage<::Protocol::CS_MOVE>(Arena*);
template<> ::Protocol::CS_PING* Arena::CreateMaybeMessage<::Protocol::CS_PING>(Arena*);
template<> ::Protocol::CS_REQ_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::CS_REQ_ENTER_GAME>(Arena*);
template<> ::Protocol::CS_REQ_MOVE_FIELD* Arena::CreateMaybeMessage<::Protocol::CS_REQ_MOVE_FIELD>(Arena*);
template<> ::Protocol::SC_DESPAWN_PLAYER* Arena::CreateMaybeMessage<::Protocol::SC_DESPAWN_PLAYER>(Arena*);
template<> ::Protocol::SC_ENTER_FIELD* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_FIELD>(Arena*);
template<> ::Protocol::SC_ENTER_GAME_RESULT* Arena::CreateMaybeMessage<::Protocol::SC_ENTER_GAME_RESULT>(Arena*);
template<> ::Protocol::SC_MOVE_FIELD_FAIL* Arena::CreateMaybeMessage<::Protocol::SC_MOVE_FIELD_FAIL>(Arena*);
template<> ::Protocol::SC_PONG* Arena::CreateMaybeMessage<::Protocol::SC_PONG>(Arena*);
template<> ::Protocol::SC_SPAWN_PLAYER* Arena::CreateMaybeMessage<::Protocol::SC_SPAWN_PLAYER>(Arena*);
template<> ::Protocol::SC_START_FIELD_LOADING* Arena::CreateMaybeMessage<::Protocol::SC_START_FIELD_LOADING>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class CS_REQ_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_REQ_ENTER_GAME) */ {
 public:
  inline CS_REQ_ENTER_GAME() : CS_REQ_ENTER_GAME(nullptr) {}
  ~CS_REQ_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR CS_REQ_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_REQ_ENTER_GAME(const CS_REQ_ENTER_GAME& from);
  CS_REQ_ENTER_GAME(CS_REQ_ENTER_GAME&& from) noexcept
    : CS_REQ_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline CS_REQ_ENTER_GAME& operator=(const CS_REQ_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_REQ_ENTER_GAME& operator=(CS_REQ_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_REQ_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_REQ_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const CS_REQ_ENTER_GAME*>(
               &_CS_REQ_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CS_REQ_ENTER_GAME& a, CS_REQ_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_REQ_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_REQ_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_REQ_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_REQ_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_REQ_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_REQ_ENTER_GAME& from) {
    CS_REQ_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_REQ_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_REQ_ENTER_GAME";
  }
  protected:
  explicit CS_REQ_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharIdFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // int32 char_id = 1;
  void clear_char_id();
  int32_t char_id() const;
  void set_char_id(int32_t value);
  private:
  int32_t _internal_char_id() const;
  void _internal_set_char_id(int32_t value);
  public:

  // int32 token = 2;
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_REQ_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t char_id_;
    int32_t token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_GAME_RESULT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_GAME_RESULT) */ {
 public:
  inline SC_ENTER_GAME_RESULT() : SC_ENTER_GAME_RESULT(nullptr) {}
  ~SC_ENTER_GAME_RESULT() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_GAME_RESULT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_GAME_RESULT(const SC_ENTER_GAME_RESULT& from);
  SC_ENTER_GAME_RESULT(SC_ENTER_GAME_RESULT&& from) noexcept
    : SC_ENTER_GAME_RESULT() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_GAME_RESULT& operator=(const SC_ENTER_GAME_RESULT& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_GAME_RESULT& operator=(SC_ENTER_GAME_RESULT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_GAME_RESULT& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_GAME_RESULT* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_GAME_RESULT*>(
               &_SC_ENTER_GAME_RESULT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SC_ENTER_GAME_RESULT& a, SC_ENTER_GAME_RESULT& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_GAME_RESULT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_GAME_RESULT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_GAME_RESULT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_GAME_RESULT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_GAME_RESULT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_GAME_RESULT& from) {
    SC_ENTER_GAME_RESULT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_GAME_RESULT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_GAME_RESULT";
  }
  protected:
  explicit SC_ENTER_GAME_RESULT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 error_code = 2;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_GAME_RESULT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_REQ_MOVE_FIELD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_REQ_MOVE_FIELD) */ {
 public:
  inline CS_REQ_MOVE_FIELD() : CS_REQ_MOVE_FIELD(nullptr) {}
  ~CS_REQ_MOVE_FIELD() override;
  explicit PROTOBUF_CONSTEXPR CS_REQ_MOVE_FIELD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_REQ_MOVE_FIELD(const CS_REQ_MOVE_FIELD& from);
  CS_REQ_MOVE_FIELD(CS_REQ_MOVE_FIELD&& from) noexcept
    : CS_REQ_MOVE_FIELD() {
    *this = ::std::move(from);
  }

  inline CS_REQ_MOVE_FIELD& operator=(const CS_REQ_MOVE_FIELD& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_REQ_MOVE_FIELD& operator=(CS_REQ_MOVE_FIELD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_REQ_MOVE_FIELD& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_REQ_MOVE_FIELD* internal_default_instance() {
    return reinterpret_cast<const CS_REQ_MOVE_FIELD*>(
               &_CS_REQ_MOVE_FIELD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CS_REQ_MOVE_FIELD& a, CS_REQ_MOVE_FIELD& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_REQ_MOVE_FIELD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_REQ_MOVE_FIELD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_REQ_MOVE_FIELD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_REQ_MOVE_FIELD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_REQ_MOVE_FIELD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_REQ_MOVE_FIELD& from) {
    CS_REQ_MOVE_FIELD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_REQ_MOVE_FIELD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_REQ_MOVE_FIELD";
  }
  protected:
  explicit CS_REQ_MOVE_FIELD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapIdFieldNumber = 1,
  };
  // uint32 map_id = 1;
  void clear_map_id();
  uint32_t map_id() const;
  void set_map_id(uint32_t value);
  private:
  uint32_t _internal_map_id() const;
  void _internal_set_map_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_REQ_MOVE_FIELD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t map_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_MOVE_FIELD_FAIL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_MOVE_FIELD_FAIL) */ {
 public:
  inline SC_MOVE_FIELD_FAIL() : SC_MOVE_FIELD_FAIL(nullptr) {}
  ~SC_MOVE_FIELD_FAIL() override;
  explicit PROTOBUF_CONSTEXPR SC_MOVE_FIELD_FAIL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_MOVE_FIELD_FAIL(const SC_MOVE_FIELD_FAIL& from);
  SC_MOVE_FIELD_FAIL(SC_MOVE_FIELD_FAIL&& from) noexcept
    : SC_MOVE_FIELD_FAIL() {
    *this = ::std::move(from);
  }

  inline SC_MOVE_FIELD_FAIL& operator=(const SC_MOVE_FIELD_FAIL& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_MOVE_FIELD_FAIL& operator=(SC_MOVE_FIELD_FAIL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_MOVE_FIELD_FAIL& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_MOVE_FIELD_FAIL* internal_default_instance() {
    return reinterpret_cast<const SC_MOVE_FIELD_FAIL*>(
               &_SC_MOVE_FIELD_FAIL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SC_MOVE_FIELD_FAIL& a, SC_MOVE_FIELD_FAIL& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_MOVE_FIELD_FAIL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_MOVE_FIELD_FAIL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_MOVE_FIELD_FAIL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_MOVE_FIELD_FAIL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_MOVE_FIELD_FAIL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_MOVE_FIELD_FAIL& from) {
    SC_MOVE_FIELD_FAIL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_MOVE_FIELD_FAIL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_MOVE_FIELD_FAIL";
  }
  protected:
  explicit SC_MOVE_FIELD_FAIL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_MOVE_FIELD_FAIL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_START_FIELD_LOADING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_START_FIELD_LOADING) */ {
 public:
  inline SC_START_FIELD_LOADING() : SC_START_FIELD_LOADING(nullptr) {}
  ~SC_START_FIELD_LOADING() override;
  explicit PROTOBUF_CONSTEXPR SC_START_FIELD_LOADING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_START_FIELD_LOADING(const SC_START_FIELD_LOADING& from);
  SC_START_FIELD_LOADING(SC_START_FIELD_LOADING&& from) noexcept
    : SC_START_FIELD_LOADING() {
    *this = ::std::move(from);
  }

  inline SC_START_FIELD_LOADING& operator=(const SC_START_FIELD_LOADING& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_START_FIELD_LOADING& operator=(SC_START_FIELD_LOADING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_START_FIELD_LOADING& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_START_FIELD_LOADING* internal_default_instance() {
    return reinterpret_cast<const SC_START_FIELD_LOADING*>(
               &_SC_START_FIELD_LOADING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SC_START_FIELD_LOADING& a, SC_START_FIELD_LOADING& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_START_FIELD_LOADING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_START_FIELD_LOADING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_START_FIELD_LOADING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_START_FIELD_LOADING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_START_FIELD_LOADING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_START_FIELD_LOADING& from) {
    SC_START_FIELD_LOADING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_START_FIELD_LOADING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_START_FIELD_LOADING";
  }
  protected:
  explicit SC_START_FIELD_LOADING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPosFieldNumber = 2,
    kTargetMapIdFieldNumber = 1,
  };
  // .Protocol.Vector3 start_pos = 2;
  bool has_start_pos() const;
  private:
  bool _internal_has_start_pos() const;
  public:
  void clear_start_pos();
  const ::Protocol::Vector3& start_pos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_start_pos();
  ::Protocol::Vector3* mutable_start_pos();
  void set_allocated_start_pos(::Protocol::Vector3* start_pos);
  private:
  const ::Protocol::Vector3& _internal_start_pos() const;
  ::Protocol::Vector3* _internal_mutable_start_pos();
  public:
  void unsafe_arena_set_allocated_start_pos(
      ::Protocol::Vector3* start_pos);
  ::Protocol::Vector3* unsafe_arena_release_start_pos();

  // uint32 target_map_id = 1;
  void clear_target_map_id();
  uint32_t target_map_id() const;
  void set_target_map_id(uint32_t value);
  private:
  uint32_t _internal_target_map_id() const;
  void _internal_set_target_map_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_START_FIELD_LOADING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector3* start_pos_;
    uint32_t target_map_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_FIELD_LOADING_COMPLETE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_FIELD_LOADING_COMPLETE) */ {
 public:
  inline CS_FIELD_LOADING_COMPLETE() : CS_FIELD_LOADING_COMPLETE(nullptr) {}
  ~CS_FIELD_LOADING_COMPLETE() override;
  explicit PROTOBUF_CONSTEXPR CS_FIELD_LOADING_COMPLETE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_FIELD_LOADING_COMPLETE(const CS_FIELD_LOADING_COMPLETE& from);
  CS_FIELD_LOADING_COMPLETE(CS_FIELD_LOADING_COMPLETE&& from) noexcept
    : CS_FIELD_LOADING_COMPLETE() {
    *this = ::std::move(from);
  }

  inline CS_FIELD_LOADING_COMPLETE& operator=(const CS_FIELD_LOADING_COMPLETE& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_FIELD_LOADING_COMPLETE& operator=(CS_FIELD_LOADING_COMPLETE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_FIELD_LOADING_COMPLETE& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_FIELD_LOADING_COMPLETE* internal_default_instance() {
    return reinterpret_cast<const CS_FIELD_LOADING_COMPLETE*>(
               &_CS_FIELD_LOADING_COMPLETE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CS_FIELD_LOADING_COMPLETE& a, CS_FIELD_LOADING_COMPLETE& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_FIELD_LOADING_COMPLETE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_FIELD_LOADING_COMPLETE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_FIELD_LOADING_COMPLETE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_FIELD_LOADING_COMPLETE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_FIELD_LOADING_COMPLETE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_FIELD_LOADING_COMPLETE& from) {
    CS_FIELD_LOADING_COMPLETE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_FIELD_LOADING_COMPLETE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_FIELD_LOADING_COMPLETE";
  }
  protected:
  explicit CS_FIELD_LOADING_COMPLETE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSuccessFieldNumber = 1,
  };
  // bool is_success = 1;
  void clear_is_success();
  bool is_success() const;
  void set_is_success(bool value);
  private:
  bool _internal_is_success() const;
  void _internal_set_is_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_FIELD_LOADING_COMPLETE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_ENTER_FIELD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_ENTER_FIELD) */ {
 public:
  inline SC_ENTER_FIELD() : SC_ENTER_FIELD(nullptr) {}
  ~SC_ENTER_FIELD() override;
  explicit PROTOBUF_CONSTEXPR SC_ENTER_FIELD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_ENTER_FIELD(const SC_ENTER_FIELD& from);
  SC_ENTER_FIELD(SC_ENTER_FIELD&& from) noexcept
    : SC_ENTER_FIELD() {
    *this = ::std::move(from);
  }

  inline SC_ENTER_FIELD& operator=(const SC_ENTER_FIELD& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_ENTER_FIELD& operator=(SC_ENTER_FIELD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_ENTER_FIELD& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_ENTER_FIELD* internal_default_instance() {
    return reinterpret_cast<const SC_ENTER_FIELD*>(
               &_SC_ENTER_FIELD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SC_ENTER_FIELD& a, SC_ENTER_FIELD& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_ENTER_FIELD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_ENTER_FIELD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_ENTER_FIELD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_ENTER_FIELD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_ENTER_FIELD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_ENTER_FIELD& from) {
    SC_ENTER_FIELD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_ENTER_FIELD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_ENTER_FIELD";
  }
  protected:
  explicit SC_ENTER_FIELD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMyInfoFieldNumber = 1,
  };
  // .Protocol.PlayerInfo my_info = 1;
  bool has_my_info() const;
  private:
  bool _internal_has_my_info() const;
  public:
  void clear_my_info();
  const ::Protocol::PlayerInfo& my_info() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_my_info();
  ::Protocol::PlayerInfo* mutable_my_info();
  void set_allocated_my_info(::Protocol::PlayerInfo* my_info);
  private:
  const ::Protocol::PlayerInfo& _internal_my_info() const;
  ::Protocol::PlayerInfo* _internal_mutable_my_info();
  public:
  void unsafe_arena_set_allocated_my_info(
      ::Protocol::PlayerInfo* my_info);
  ::Protocol::PlayerInfo* unsafe_arena_release_my_info();

  // @@protoc_insertion_point(class_scope:Protocol.SC_ENTER_FIELD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* my_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_SPAWN_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_SPAWN_PLAYER) */ {
 public:
  inline SC_SPAWN_PLAYER() : SC_SPAWN_PLAYER(nullptr) {}
  ~SC_SPAWN_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR SC_SPAWN_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_SPAWN_PLAYER(const SC_SPAWN_PLAYER& from);
  SC_SPAWN_PLAYER(SC_SPAWN_PLAYER&& from) noexcept
    : SC_SPAWN_PLAYER() {
    *this = ::std::move(from);
  }

  inline SC_SPAWN_PLAYER& operator=(const SC_SPAWN_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_SPAWN_PLAYER& operator=(SC_SPAWN_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_SPAWN_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_SPAWN_PLAYER* internal_default_instance() {
    return reinterpret_cast<const SC_SPAWN_PLAYER*>(
               &_SC_SPAWN_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SC_SPAWN_PLAYER& a, SC_SPAWN_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_SPAWN_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_SPAWN_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_SPAWN_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_SPAWN_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_SPAWN_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_SPAWN_PLAYER& from) {
    SC_SPAWN_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_SPAWN_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_SPAWN_PLAYER";
  }
  protected:
  explicit SC_SPAWN_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Protocol.PlayerInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Protocol::PlayerInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_info();
  private:
  const ::Protocol::PlayerInfo& _internal_info(int index) const;
  ::Protocol::PlayerInfo* _internal_add_info();
  public:
  const ::Protocol::PlayerInfo& info(int index) const;
  ::Protocol::PlayerInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:Protocol.SC_SPAWN_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_DESPAWN_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_DESPAWN_PLAYER) */ {
 public:
  inline SC_DESPAWN_PLAYER() : SC_DESPAWN_PLAYER(nullptr) {}
  ~SC_DESPAWN_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR SC_DESPAWN_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_DESPAWN_PLAYER(const SC_DESPAWN_PLAYER& from);
  SC_DESPAWN_PLAYER(SC_DESPAWN_PLAYER&& from) noexcept
    : SC_DESPAWN_PLAYER() {
    *this = ::std::move(from);
  }

  inline SC_DESPAWN_PLAYER& operator=(const SC_DESPAWN_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_DESPAWN_PLAYER& operator=(SC_DESPAWN_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_DESPAWN_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_DESPAWN_PLAYER* internal_default_instance() {
    return reinterpret_cast<const SC_DESPAWN_PLAYER*>(
               &_SC_DESPAWN_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SC_DESPAWN_PLAYER& a, SC_DESPAWN_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_DESPAWN_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_DESPAWN_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_DESPAWN_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_DESPAWN_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_DESPAWN_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_DESPAWN_PLAYER& from) {
    SC_DESPAWN_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_DESPAWN_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_DESPAWN_PLAYER";
  }
  protected:
  explicit SC_DESPAWN_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // repeated uint64 player_id = 1;
  int player_id_size() const;
  private:
  int _internal_player_id_size() const;
  public:
  void clear_player_id();
  private:
  uint64_t _internal_player_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_player_id() const;
  void _internal_add_player_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_player_id();
  public:
  uint64_t player_id(int index) const;
  void set_player_id(int index, uint64_t value);
  void add_player_id(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      player_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_player_id();

  // @@protoc_insertion_point(class_scope:Protocol.SC_DESPAWN_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > player_id_;
    mutable std::atomic<int> _player_id_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_MOVE) */ {
 public:
  inline CS_MOVE() : CS_MOVE(nullptr) {}
  ~CS_MOVE() override;
  explicit PROTOBUF_CONSTEXPR CS_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_MOVE(const CS_MOVE& from);
  CS_MOVE(CS_MOVE&& from) noexcept
    : CS_MOVE() {
    *this = ::std::move(from);
  }

  inline CS_MOVE& operator=(const CS_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_MOVE& operator=(CS_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_MOVE* internal_default_instance() {
    return reinterpret_cast<const CS_MOVE*>(
               &_CS_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CS_MOVE& a, CS_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_MOVE& from) {
    CS_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_MOVE";
  }
  protected:
  explicit CS_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // .Protocol.Vector3 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Protocol::Vector3& pos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_pos();
  ::Protocol::Vector3* mutable_pos();
  void set_allocated_pos(::Protocol::Vector3* pos);
  private:
  const ::Protocol::Vector3& _internal_pos() const;
  ::Protocol::Vector3* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Protocol::Vector3* pos);
  ::Protocol::Vector3* unsafe_arena_release_pos();

  // @@protoc_insertion_point(class_scope:Protocol.CS_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector3* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CS_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_PING) */ {
 public:
  inline CS_PING() : CS_PING(nullptr) {}
  ~CS_PING() override;
  explicit PROTOBUF_CONSTEXPR CS_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_PING(const CS_PING& from);
  CS_PING(CS_PING&& from) noexcept
    : CS_PING() {
    *this = ::std::move(from);
  }

  inline CS_PING& operator=(const CS_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_PING& operator=(CS_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_PING* internal_default_instance() {
    return reinterpret_cast<const CS_PING*>(
               &_CS_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CS_PING& a, CS_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_PING& from) {
    CS_PING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_PING";
  }
  protected:
  explicit CS_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SC_PONG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_PONG) */ {
 public:
  inline SC_PONG() : SC_PONG(nullptr) {}
  ~SC_PONG() override;
  explicit PROTOBUF_CONSTEXPR SC_PONG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_PONG(const SC_PONG& from);
  SC_PONG(SC_PONG&& from) noexcept
    : SC_PONG() {
    *this = ::std::move(from);
  }

  inline SC_PONG& operator=(const SC_PONG& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_PONG& operator=(SC_PONG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_PONG& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_PONG* internal_default_instance() {
    return reinterpret_cast<const SC_PONG*>(
               &_SC_PONG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SC_PONG& a, SC_PONG& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_PONG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_PONG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_PONG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_PONG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_PONG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_PONG& from) {
    SC_PONG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_PONG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_PONG";
  }
  protected:
  explicit SC_PONG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_PONG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CS_REQ_ENTER_GAME

// int32 char_id = 1;
inline void CS_REQ_ENTER_GAME::clear_char_id() {
  _impl_.char_id_ = 0;
}
inline int32_t CS_REQ_ENTER_GAME::_internal_char_id() const {
  return _impl_.char_id_;
}
inline int32_t CS_REQ_ENTER_GAME::char_id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REQ_ENTER_GAME.char_id)
  return _internal_char_id();
}
inline void CS_REQ_ENTER_GAME::_internal_set_char_id(int32_t value) {
  
  _impl_.char_id_ = value;
}
inline void CS_REQ_ENTER_GAME::set_char_id(int32_t value) {
  _internal_set_char_id(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_REQ_ENTER_GAME.char_id)
}

// int32 token = 2;
inline void CS_REQ_ENTER_GAME::clear_token() {
  _impl_.token_ = 0;
}
inline int32_t CS_REQ_ENTER_GAME::_internal_token() const {
  return _impl_.token_;
}
inline int32_t CS_REQ_ENTER_GAME::token() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REQ_ENTER_GAME.token)
  return _internal_token();
}
inline void CS_REQ_ENTER_GAME::_internal_set_token(int32_t value) {
  
  _impl_.token_ = value;
}
inline void CS_REQ_ENTER_GAME::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_REQ_ENTER_GAME.token)
}

// -------------------------------------------------------------------

// SC_ENTER_GAME_RESULT

// bool success = 1;
inline void SC_ENTER_GAME_RESULT::clear_success() {
  _impl_.success_ = false;
}
inline bool SC_ENTER_GAME_RESULT::_internal_success() const {
  return _impl_.success_;
}
inline bool SC_ENTER_GAME_RESULT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_GAME_RESULT.success)
  return _internal_success();
}
inline void SC_ENTER_GAME_RESULT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SC_ENTER_GAME_RESULT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_GAME_RESULT.success)
}

// int32 error_code = 2;
inline void SC_ENTER_GAME_RESULT::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t SC_ENTER_GAME_RESULT::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t SC_ENTER_GAME_RESULT::error_code() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_GAME_RESULT.error_code)
  return _internal_error_code();
}
inline void SC_ENTER_GAME_RESULT::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void SC_ENTER_GAME_RESULT::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_ENTER_GAME_RESULT.error_code)
}

// -------------------------------------------------------------------

// CS_REQ_MOVE_FIELD

// uint32 map_id = 1;
inline void CS_REQ_MOVE_FIELD::clear_map_id() {
  _impl_.map_id_ = 0u;
}
inline uint32_t CS_REQ_MOVE_FIELD::_internal_map_id() const {
  return _impl_.map_id_;
}
inline uint32_t CS_REQ_MOVE_FIELD::map_id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_REQ_MOVE_FIELD.map_id)
  return _internal_map_id();
}
inline void CS_REQ_MOVE_FIELD::_internal_set_map_id(uint32_t value) {
  
  _impl_.map_id_ = value;
}
inline void CS_REQ_MOVE_FIELD::set_map_id(uint32_t value) {
  _internal_set_map_id(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_REQ_MOVE_FIELD.map_id)
}

// -------------------------------------------------------------------

// SC_MOVE_FIELD_FAIL

// int32 error_code = 1;
inline void SC_MOVE_FIELD_FAIL::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t SC_MOVE_FIELD_FAIL::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t SC_MOVE_FIELD_FAIL::error_code() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_MOVE_FIELD_FAIL.error_code)
  return _internal_error_code();
}
inline void SC_MOVE_FIELD_FAIL::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void SC_MOVE_FIELD_FAIL::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_MOVE_FIELD_FAIL.error_code)
}

// -------------------------------------------------------------------

// SC_START_FIELD_LOADING

// uint32 target_map_id = 1;
inline void SC_START_FIELD_LOADING::clear_target_map_id() {
  _impl_.target_map_id_ = 0u;
}
inline uint32_t SC_START_FIELD_LOADING::_internal_target_map_id() const {
  return _impl_.target_map_id_;
}
inline uint32_t SC_START_FIELD_LOADING::target_map_id() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_START_FIELD_LOADING.target_map_id)
  return _internal_target_map_id();
}
inline void SC_START_FIELD_LOADING::_internal_set_target_map_id(uint32_t value) {
  
  _impl_.target_map_id_ = value;
}
inline void SC_START_FIELD_LOADING::set_target_map_id(uint32_t value) {
  _internal_set_target_map_id(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_START_FIELD_LOADING.target_map_id)
}

// .Protocol.Vector3 start_pos = 2;
inline bool SC_START_FIELD_LOADING::_internal_has_start_pos() const {
  return this != internal_default_instance() && _impl_.start_pos_ != nullptr;
}
inline bool SC_START_FIELD_LOADING::has_start_pos() const {
  return _internal_has_start_pos();
}
inline const ::Protocol::Vector3& SC_START_FIELD_LOADING::_internal_start_pos() const {
  const ::Protocol::Vector3* p = _impl_.start_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& SC_START_FIELD_LOADING::start_pos() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_START_FIELD_LOADING.start_pos)
  return _internal_start_pos();
}
inline void SC_START_FIELD_LOADING::unsafe_arena_set_allocated_start_pos(
    ::Protocol::Vector3* start_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_pos_);
  }
  _impl_.start_pos_ = start_pos;
  if (start_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_START_FIELD_LOADING.start_pos)
}
inline ::Protocol::Vector3* SC_START_FIELD_LOADING::release_start_pos() {
  
  ::Protocol::Vector3* temp = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* SC_START_FIELD_LOADING::unsafe_arena_release_start_pos() {
  // @@protoc_insertion_point(field_release:Protocol.SC_START_FIELD_LOADING.start_pos)
  
  ::Protocol::Vector3* temp = _impl_.start_pos_;
  _impl_.start_pos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* SC_START_FIELD_LOADING::_internal_mutable_start_pos() {
  
  if (_impl_.start_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.start_pos_ = p;
  }
  return _impl_.start_pos_;
}
inline ::Protocol::Vector3* SC_START_FIELD_LOADING::mutable_start_pos() {
  ::Protocol::Vector3* _msg = _internal_mutable_start_pos();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_START_FIELD_LOADING.start_pos)
  return _msg;
}
inline void SC_START_FIELD_LOADING::set_allocated_start_pos(::Protocol::Vector3* start_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_pos_);
  }
  if (start_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pos));
    if (message_arena != submessage_arena) {
      start_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_pos_ = start_pos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_START_FIELD_LOADING.start_pos)
}

// -------------------------------------------------------------------

// CS_FIELD_LOADING_COMPLETE

// bool is_success = 1;
inline void CS_FIELD_LOADING_COMPLETE::clear_is_success() {
  _impl_.is_success_ = false;
}
inline bool CS_FIELD_LOADING_COMPLETE::_internal_is_success() const {
  return _impl_.is_success_;
}
inline bool CS_FIELD_LOADING_COMPLETE::is_success() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_FIELD_LOADING_COMPLETE.is_success)
  return _internal_is_success();
}
inline void CS_FIELD_LOADING_COMPLETE::_internal_set_is_success(bool value) {
  
  _impl_.is_success_ = value;
}
inline void CS_FIELD_LOADING_COMPLETE::set_is_success(bool value) {
  _internal_set_is_success(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_FIELD_LOADING_COMPLETE.is_success)
}

// -------------------------------------------------------------------

// SC_ENTER_FIELD

// .Protocol.PlayerInfo my_info = 1;
inline bool SC_ENTER_FIELD::_internal_has_my_info() const {
  return this != internal_default_instance() && _impl_.my_info_ != nullptr;
}
inline bool SC_ENTER_FIELD::has_my_info() const {
  return _internal_has_my_info();
}
inline const ::Protocol::PlayerInfo& SC_ENTER_FIELD::_internal_my_info() const {
  const ::Protocol::PlayerInfo* p = _impl_.my_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& SC_ENTER_FIELD::my_info() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_ENTER_FIELD.my_info)
  return _internal_my_info();
}
inline void SC_ENTER_FIELD::unsafe_arena_set_allocated_my_info(
    ::Protocol::PlayerInfo* my_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_info_);
  }
  _impl_.my_info_ = my_info;
  if (my_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SC_ENTER_FIELD.my_info)
}
inline ::Protocol::PlayerInfo* SC_ENTER_FIELD::release_my_info() {
  
  ::Protocol::PlayerInfo* temp = _impl_.my_info_;
  _impl_.my_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* SC_ENTER_FIELD::unsafe_arena_release_my_info() {
  // @@protoc_insertion_point(field_release:Protocol.SC_ENTER_FIELD.my_info)
  
  ::Protocol::PlayerInfo* temp = _impl_.my_info_;
  _impl_.my_info_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* SC_ENTER_FIELD::_internal_mutable_my_info() {
  
  if (_impl_.my_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.my_info_ = p;
  }
  return _impl_.my_info_;
}
inline ::Protocol::PlayerInfo* SC_ENTER_FIELD::mutable_my_info() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_my_info();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_ENTER_FIELD.my_info)
  return _msg;
}
inline void SC_ENTER_FIELD::set_allocated_my_info(::Protocol::PlayerInfo* my_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_info_);
  }
  if (my_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(my_info));
    if (message_arena != submessage_arena) {
      my_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, my_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.my_info_ = my_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_ENTER_FIELD.my_info)
}

// -------------------------------------------------------------------

// SC_SPAWN_PLAYER

// repeated .Protocol.PlayerInfo info = 1;
inline int SC_SPAWN_PLAYER::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int SC_SPAWN_PLAYER::info_size() const {
  return _internal_info_size();
}
inline ::Protocol::PlayerInfo* SC_SPAWN_PLAYER::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.SC_SPAWN_PLAYER.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
SC_SPAWN_PLAYER::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_SPAWN_PLAYER.info)
  return &_impl_.info_;
}
inline const ::Protocol::PlayerInfo& SC_SPAWN_PLAYER::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Protocol::PlayerInfo& SC_SPAWN_PLAYER::info(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_SPAWN_PLAYER.info)
  return _internal_info(index);
}
inline ::Protocol::PlayerInfo* SC_SPAWN_PLAYER::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Protocol::PlayerInfo* SC_SPAWN_PLAYER::add_info() {
  ::Protocol::PlayerInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Protocol.SC_SPAWN_PLAYER.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
SC_SPAWN_PLAYER::info() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_SPAWN_PLAYER.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// SC_DESPAWN_PLAYER

// repeated uint64 player_id = 1;
inline int SC_DESPAWN_PLAYER::_internal_player_id_size() const {
  return _impl_.player_id_.size();
}
inline int SC_DESPAWN_PLAYER::player_id_size() const {
  return _internal_player_id_size();
}
inline void SC_DESPAWN_PLAYER::clear_player_id() {
  _impl_.player_id_.Clear();
}
inline uint64_t SC_DESPAWN_PLAYER::_internal_player_id(int index) const {
  return _impl_.player_id_.Get(index);
}
inline uint64_t SC_DESPAWN_PLAYER::player_id(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.SC_DESPAWN_PLAYER.player_id)
  return _internal_player_id(index);
}
inline void SC_DESPAWN_PLAYER::set_player_id(int index, uint64_t value) {
  _impl_.player_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.SC_DESPAWN_PLAYER.player_id)
}
inline void SC_DESPAWN_PLAYER::_internal_add_player_id(uint64_t value) {
  _impl_.player_id_.Add(value);
}
inline void SC_DESPAWN_PLAYER::add_player_id(uint64_t value) {
  _internal_add_player_id(value);
  // @@protoc_insertion_point(field_add:Protocol.SC_DESPAWN_PLAYER.player_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SC_DESPAWN_PLAYER::_internal_player_id() const {
  return _impl_.player_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SC_DESPAWN_PLAYER::player_id() const {
  // @@protoc_insertion_point(field_list:Protocol.SC_DESPAWN_PLAYER.player_id)
  return _internal_player_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SC_DESPAWN_PLAYER::_internal_mutable_player_id() {
  return &_impl_.player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SC_DESPAWN_PLAYER::mutable_player_id() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.SC_DESPAWN_PLAYER.player_id)
  return _internal_mutable_player_id();
}

// -------------------------------------------------------------------

// CS_MOVE

// .Protocol.Vector3 pos = 1;
inline bool CS_MOVE::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool CS_MOVE::has_pos() const {
  return _internal_has_pos();
}
inline const ::Protocol::Vector3& CS_MOVE::_internal_pos() const {
  const ::Protocol::Vector3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& CS_MOVE::pos() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_MOVE.pos)
  return _internal_pos();
}
inline void CS_MOVE::unsafe_arena_set_allocated_pos(
    ::Protocol::Vector3* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CS_MOVE.pos)
}
inline ::Protocol::Vector3* CS_MOVE::release_pos() {
  
  ::Protocol::Vector3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* CS_MOVE::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Protocol.CS_MOVE.pos)
  
  ::Protocol::Vector3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* CS_MOVE::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Protocol::Vector3* CS_MOVE::mutable_pos() {
  ::Protocol::Vector3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_MOVE.pos)
  return _msg;
}
inline void CS_MOVE::set_allocated_pos(::Protocol::Vector3* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_MOVE.pos)
}

// -------------------------------------------------------------------

// CS_PING

// int32 id = 1;
inline void CS_PING::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t CS_PING::_internal_id() const {
  return _impl_.id_;
}
inline int32_t CS_PING::id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_PING.id)
  return _internal_id();
}
inline void CS_PING::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void CS_PING::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_PING.id)
}

// -------------------------------------------------------------------

// SC_PONG

// int32 id = 1;
inline void SC_PONG::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t SC_PONG::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SC_PONG::id() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_PONG.id)
  return _internal_id();
}
inline void SC_PONG::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void SC_PONG::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_PONG.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
